# TinyJib - Containerize your Gradle Java project

For information about the project, see the [TinyJib project README](README.md).

## Table of Contents

* [Quickstart](#quickstart)
    * [Setup](#setup)
    * [Configuration](#configuration)
    * [Build your image](#build-your-image)
        * [Build to Docker Daemon](#build-to-docker-daemon)
        * [Build an image tarball](#build-an-image-tarball)
    * [Additional Build Artifacts](#additional-build-artifacts)
* [Extended Usage](#extended-usage)
    * [Global Jib Configuration](#global-jib-configuration)
    * [Example](#example)
    * [Adding Arbitrary Files to the Image](#adding-arbitrary-files-to-the-image)
    * [Authentication Methods](#authentication-methods)
        * [Using Docker configuration files](#using-docker-configuration-files)
        * [Using Docker Credential Helpers](#using-docker-credential-helpers)
        * [Using Specific Credentials](#using-specific-credentials)
    * [Custom Container Entrypoint](#custom-container-entrypoint)
    * [Reproducible Build Timestamps](#reproducible-build-timestamps)

## Quickstart

### Setup

*Make sure you are using Gradle version 9 or later.*

In your Gradle Java project, add the plugin to your `build.gradle.kts`:

```kotlin
plugins {
  id("tel.schich.tinyjib") version "0.1.0"
}
```

*See the [Gradle Plugin Portal](https://plugins.gradle.org/plugin/tel.schich.tinyjib) for more details.*

This builds and pushes a container image for your application to a container registry. *If you encounter authentication issues, see [Authentication Methods](#authentication-methods).*

To build to a Docker daemon, use:

```shell
gradle tinyJibDocker
```

If you would like to set up TinyJib as part of your Gradle build, follow the guide below.

## Configuration

Configure the plugin by setting the image to push to:

```kotlin
tinyJib.to.image = "gcr.io/my-gcp-project/my-app"
```

### Build Your Image

Build your container image with:

```shell
gradle tinyJibPublish
```

Subsequent builds are much faster than the initial build.

#### Build to Docker daemon

TinyJib can also build your image directly to a Docker daemon. This uses the `docker` command line tool and requires that you have `docker` available on your `PATH`.

```shell
gradle tinyJibDocker
```

#### Build an image tarball

You can build and save your image to disk as a tarball with:

```shell
gradle tinyJibTar
```

This builds and saves your image to `build/tiny-jib-image.tar`, which you can load into docker with:

```shell
docker load --input build/tiny-jib-image.tar
```

### Additional Build Artifacts

As part of an image build, TinyJib also writes out the _image digest_ and the _image ID_. By default, these are written out to `build/tiny-jib-image.digest` and `build/tiny-jib-image.id` respectively, but the locations can be configured using the `tinyJib.outputPaths.digest` and `tinyJib.outputPaths.imageId` configuration properties. See [Extended Usage](#outputpaths-closure) for more details.

## Extended Usage

The plugin provides the `tinyJib` extension for configuration with the following options for customizing the image build:

Field | Type | Default | Description
--- | --- | --- | ---
`to` | [`to`](#to-closure) | *Required* | Configures the target image to build your application to.
`from` | [`from`](#from-closure) | See [`from`](#from-closure) | Configures the base image to build your application on top of.
`container` | [`container`](#container-closure) | See [`container`](#container-closure) | Configures the container that is run from your built image.
`extraDirectories` | [`extraDirectories`](#extradirectories-closure) | See [`extraDirectories`](#extradirectories-closure) | Configures the directories used to add arbitrary files to the image.
`outputPaths` | [`outputPaths`](#outputpaths-closure) | See [`outputPaths`](#outputpaths-closure) | Configures the locations of additional build artifacts generated by Jib.
`dockerClient` | [`dockerClient`](#dockerclient-closure) | See [`dockerClient`](#dockerclient-closure) | Configures Docker for building to/from the Docker daemon.
`skaffold` | [`skaffold`](#skaffold-integration) | See [`skaffold`](#skaffold-integration) | Configures the internal skaffold tasks. This configuration should only be used when integrating with [`skaffold`](#skaffold-integration). |
`containerizingMode` | `String` | `exploded` | If set to `packaged`, puts the JAR artifact built by the Gradle Java plugin into the final image. If set to `exploded` (default), containerizes individual `.class` files and resources files.
`allowInsecureRegistries` | `boolean` | `false` | If set to true, Jib ignores HTTPS certificate errors and may fall back to HTTP as a last resort. Leaving this parameter set to `false` is strongly recommended, since HTTP communication is unencrypted and visible to others on the network, and insecure HTTPS is no better than plain HTTP. [If accessing a registry with a self-signed certificate, adding the certificate to your Java runtime's trusted keys](https://github.com/GoogleContainerTools/jib/tree/master/docs/self_sign_cert.md) may be an alternative to enabling this option.
`configurationName` | `String` | `runtimeClasspath` | Specify the name of the [Gradle Configuration](https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ConfigurationContainer.html) to use.

<a name="from-closure"></a>`from` is a closure with the following properties:

Property | Type | Default                                                    | Description
--- | --- |------------------------------------------------------------| ---
`image` | `String` | `eclipse-temurin:{8,11,17,21,25}-jre` (or `jetty` for WAR) | The image reference for the base image. The source type can be specified using a [special type prefix](#setting-the-base-image).
`auth` | [`auth`](#auth-closure) | *None*                                                     | Specifies credentials directly (alternative to `credHelper`).
`credHelper` | `String` | *None*                                                     | Specifies a credential helper that can authenticate pulling the base image. This parameter can either be configured as an absolute path to the credential helper executable or as a credential helper suffix (following `docker-credential-`).
`platforms` | [`platforms`](#platforms-closure) | See [`platforms`](#platforms-closure)                      | Configures platforms of base images to select from a manifest list.

<a name="to-closure"></a>`to` is a closure with the following properties:

Property | Type | Default | Description
--- | --- | --- | ---
`image` | `String` | *Required* | The image reference for the target image. This can also be specified via the `--image` command line option. If the tag is not present here `:latest` is implied.
`auth` | [`auth`](#auth-closure) | *None* | Specifies credentials directly (alternative to `credHelper`).
`credHelper` | `String` | *None* | Specifies a credential helper that can authenticate pushing the target image. This parameter can either be configured as an absolute path to the credential helper executable or as a credential helper suffix (following `docker-credential-`).
`tags` | `List<String>` | *None* | Additional tags to push to.

<a name="auth-closure"></a>`auth` is a closure with the following properties (see [Using Specific Credentials](#using-specific-credentials)):

Property | Type
--- | ---
`username` | `String`
`password` | `String`

<a name="platforms-closure"></a>`platforms` can configure multiple `platform` closures.  Each individual `platform` has the following properties:

Property | Type | Default | Description
--- | --- | --- | ---
`architecture` | `String` | `amd64` | The architecture of a base image to select from a manifest list.
`os` | `String` | `linux` | The OS of a base image to select from a manifest list.

See [How do I specify a platform in the manifest list (or OCI index) of a base image?](../docs/faq.md#how-do-i-specify-a-platform-in-the-manifest-list-or-oci-index-of-a-base-image) for examples.

<a name="container-closure"></a>`container` is a closure with the following properties:

Property | Type | Default | Description
--- | --- | --- | ---
`appRoot` | `String` | `/app` | The root directory on the container where the app's contents are placed. Particularly useful for WAR-packaging projects to work with different Servlet engine base images by designating where to put exploded WAR contents; see [WAR usage](#war-projects) as an example.
`args` | `List<String>` | *None* | Additional program arguments appended to the command to start the container (similar to Docker's [CMD](https://docs.docker.com/engine/reference/builder/#cmd) instruction in relation with [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint)). In the default case where you do not set a custom `entrypoint`, this parameter is effectively the arguments to the main method of your Java application.
`creationTime` | `String` | `EPOCH` | Sets the container creation time. (Note that this property does not affect the file modification times, which are configured using `jib.container.filesModificationTime`.) The value can be `EPOCH` to set the timestamps to Epoch (default behavior), `USE_CURRENT_TIMESTAMP` to forgo reproducibility and use the real creation time, or an ISO 8601 date-time parsable with [`DateTimeFormatter.ISO_DATE_TIME`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME) such as `2019-07-15T10:15:30+09:00` or `2011-12-03T22:42:05Z`. The value can also be initialized [lazily](https://docs.gradle.org/current/userguide/lazy_configuration.html) with a provider.
`entrypoint` | `List<String>` | *None* | The command to start the container with (similar to Docker's [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) instruction). If set, then `jvmFlags`, `mainClass`, `extraClasspath`, and `expandClasspathDependencies` are ignored. You may also set `tinyJib.container.entrypoint = "INHERIT"` to indicate that the `entrypoint` and `args` should be inherited from the base image.\* The value can also be initialized [lazily](https://docs.gradle.org/current/userguide/lazy_configuration.html) with a provider.
`environment` | `Map<String, String>` | *None* | Key-value pairs for setting environment variables on the container (similar to Docker's [ENV](https://docs.docker.com/engine/reference/builder/#env) instruction).
`extraClasspath` | `List<String>` | *None* | Additional paths in the container to prepend to the computed Java classpath.
`expandClasspathDependencies` | `boolean` | `false` | <ul><li>Java 8 *or* Jib < 3.1: When set to true, does not use a wildcard (for example, `/app/lib/*`) for dependency JARs in the default Java runtime classpath but instead enumerates the JARs. Has the effect of preserving the classpath loading order as defined by the Gradle project.</li><li>Java >= 9 *and* Jib >= 3.1: The option has no effect. Jib *always* enumerates the dependency JARs. This is achieved by [creating and using an argument file](#custom-container-entrypoint) for the `--class-path` JVM argument.</li></ul>
`filesModificationTime` | `String` | `EPOCH_PLUS_SECOND` | Sets the modification time (last modified time) of files in the image put by Jib. (Note that this does not set the image creation time, which can be set using `tinyJib.container.creationTime`.) The value should either be `EPOCH_PLUS_SECOND` to set the timestamps to Epoch + 1 second (default behavior), or an ISO 8601 date-time parsable with [`DateTimeFormatter.ISO_DATE_TIME`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME) such as `2019-07-15T10:15:30+09:00` or `2011-12-03T22:42:05Z`. The value can also be initialized [lazily](https://docs.gradle.org/current/userguide/lazy_configuration.html) with a provider.
`format` | `String` | `Docker` | Use `OCI` to build an [OCI container image](https://www.opencontainers.org/).
`jvmFlags` | `List<String>` | *None* | Additional flags to pass into the JVM when running your application. The value can also be initialized [lazily](https://docs.gradle.org/current/userguide/lazy_configuration.html) with a provider.
`labels` | `Map<String, String>` | *None* | Key-value pairs for applying image metadata (similar to Docker's [LABEL](https://docs.docker.com/engine/reference/builder/#label) instruction).
`mainClass` | `String` | *Inferred*\*\* | The main class to launch your application from. The value can also be initialized [lazily](https://docs.gradle.org/current/userguide/lazy_configuration.html) with a provider.
`ports` | `List<String>` | *None* | Ports that the container exposes at runtime (similar to Docker's [EXPOSE](https://docs.docker.com/engine/reference/builder/#expose) instruction).
`user` | `String` | *None* | The user and group to run the container as. The value can be a username or UID along with an optional groupname or GID. The following are all valid: `user`, `uid`, `user:group`, `uid:gid`, `uid:group`, `user:gid`.
`volumes` | `List<String>` | *None* | Specifies a list of mount points on the container.
`workingDirectory` | `String` | *None* | The working directory in the container.

<a name="extradirectories-closure"></a>`extraDirectories` is a closure with the following properties (see [Adding Arbitrary Files to the Image](#adding-arbitrary-files-to-the-image)):

Property | Type | Default | Description
--- | --- | --- | ---
`paths` | [`paths`](#paths-closure) closure, or `Object` | `(project-dir)/src/main/jib` | May be configured as a closure configuring `path` elements, or as source directory values recognized by [`Project.files()`](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#files-java.lang.Object...-), such as `String`, `File`, `Path`, `List<String\|File\|Path>`, etc.
`permissions` | `Map<String, String>` | *None* | Maps file paths (glob patterns) on container to Unix permissions. (Effective only for files added from extra directories.) If not configured, permissions default to "755" for directories and "644" for files. See [Adding Arbitrary Files to the Image](#adding-arbitrary-files-to-the-image) for an example.

<a name="paths-closure"></a>`paths` can configure multiple `path` closures (see [Adding Arbitrary Files to the Image](#adding-arbitrary-files-to-the-image)). Each individual `path` has the following properties:

Property | Type | Default | Description
--- | --- | --- | ---
`from` | `Object` | `(project-dir)/src/main/jib` | Accepts source directories that are recognized by [`Project.files()`](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#files-java.lang.Object...-), such as `String`, `File`, `Path`, `List<String\|File\|Path>`, etc.
`into` | `String` | `/` | The absolute unix path on the container to copy the extra directory contents into.
`includes` | `List<String>` | *None* | Glob patterns for including files. See [Adding Arbitrary Files to the Image](#adding-arbitrary-files-to-the-image) for an example.
`excludes` | `List<String>` | *None* | Glob patterns for excluding files. See [Adding Arbitrary Files to the Image](#adding-arbitrary-files-to-the-image) for an example.

<a name="outputpaths-closure"></a>`outputPaths` is a closure with the following properties:

Property | Type | Default                                  | Description
--- | --- |------------------------------------------| ---
`tar` | `File` | `(project-dir)/build/tiny-jib-image.tar` | The path of the tarball generated by `tinyJibTar`. Relative paths are resolved relative to the project root.
`digest` | `File` | `(project-dir)/build/tiny-jib-image.digest`   | The path of the image digest written out during the build. Relative paths are resolved relative to the project root.
`imageId` | `File` | `(project-dir)/build/tiny-jib-image.id`       | The path of the image ID written out during the build. Relative paths are resolved relative to the project root.

<a name="dockerclient-closure"></a>`dockerClient` is an object used to configure Docker when building to/from the Docker daemon. It has the following properties:

Property | Type | Default | Description
--- | --- | --- | ---
`executable` | `File` | `docker` | Sets the path to the Docker executable that is called to load the image into the Docker daemon. **Please note**: Users are responsible for ensuring that the Docker path passed in is valid and has the right permissions to be executed.
`environment` | `Map<String, String>` | *None* | Sets environment variables used by the Docker executable.

### Global Jib Configuration

Some options can be set in the global Jib configuration file. The file is at the following locations on each platform:

* *Linux: `[config root]/google-cloud-tools-java/jib/config.json`, where `[config root]` is `$XDG_CONFIG_HOME` (`$HOME/.config/` if not set)*
* *Mac: `[config root]/Google/Jib/config.json`, where `[config root]` is `$XDG_CONFIG_HOME` (`$HOME/Library/Preferences/Config/` if not set)*
* *Windows: `[config root]\Google\Jib\Config\config.json`, where `[config root]` is `%XDG_CONFIG_HOME%` (`%LOCALAPPDATA%` if not set)*

#### Properties

* `disableUpdateCheck`: when set to true, disables the periodic up-to-date version check.
* `registryMirrors`: a list of mirror settings for each base image registry. In the following example, if the base image configured in Jib is for a Docker Hub image, then `mirror.gcr.io`, `localhost:5000`, and the Docker Hub (`registry-1.docker.io`) are tried in order until Jib can successfully pull a base image.

```json
{
  "disableUpdateCheck": false,
  "registryMirrors": [
    {
      "registry": "registry-1.docker.io",
      "mirrors": ["mirror.gcr.io", "localhost:5000"]
    },
    {
      "registry": "quay.io",
      "mirrors": ["private-mirror.test.com"]
    }
  ]
}
```
**Note about `mirror.gcr.io`**: it is _not_ a Docker Hub mirror but a cache. It caches [frequently-accessed public Docker Hub images](https://cloud.google.com/container-registry/docs/pulling-cached-images), and it's often possible that your base image does not exist in `mirror.gcr.io`. In that case, Jib will have to fall back to use Docker Hub.

### Example

In this configuration, the image:
* Is built from a base of `openjdk:alpine` (pulled from Docker Hub)
* Is pushed to `localhost:5000/my-image:built-with-jib`, `localhost:5000/my-image:tag2`, and `localhost:5000/my-image:latest`
* Runs by calling `java -Dmy.property=example.value -Xms512m -Xdebug -cp app/libs/*:app/resources:app/classes mypackage.MyApp some args`
* Exposes port 1000 for tcp (default), and ports 2000, 2001, 2002, and 2003 for udp
* Has two labels (key1:value1 and key2:value2)
* Is built as OCI format

```kotlin
tinyJib {
  from {
    image = "openjdk:alpine"
  }
  to {
    image = "localhost:5000/my-image/built-with-jib"
    credHelper = "osxkeychain"
    tags = listOf("tag2", "latest")
  }
  container {
    jvmFlags = listOf("-Dmy.property=example.value", "-Xms512m", "-Xdebug")
    mainClass = "mypackage.MyApp"
    args = listOf("some", "args")
    ports = listOf("1000", "2000-2003/udp")
    labels = mapOf(
      "key1" to "value1",
      "key2" to "value2",
    )
  }
}
```

### Setting the Base Image

There are three different types of base images that Jib accepts: an image from a container registry, an image stored in the Docker daemon, or an image tarball on the local filesystem. You can specify which you would like to use by prepending the `jib.from.image` configuration with a special prefix, listed below:

Prefix | Example | Type
--- | --- | ---
*None* | `openjdk:11-jre` | Pulls the base image from a registry.
`registry://` | `registry://eclipse-temurin:11-jre` | Pulls the base image from a registry.
`docker://` | `docker://busybox` | Retrieves the base image from the Docker daemon.
`tar://` | `tar:///path/to/file.tar` | Uses an image tarball stored at the specified path as the base image. Also accepts relative paths (e.g. `tar://build/tiny-jib-image.tar`).

### Adding Arbitrary Files to the Image

You can add arbitrary, non-classpath files to the image without extra configuration by placing them in a `src/main/jib` directory. This will copy all files within the `jib` folder to the target directory (`/` by default) in the image, maintaining the same structure (e.g. if you have a text file at `src/main/jib/dir/hello.txt`, then your image will contain `/dir/hello.txt` after being built with Jib).

Note that Jib does not follow symbolic links in the container image.  If a symbolic link is present, _it will be removed_ prior to placing the files and directories.

You can configure different directories by using the `tinyJib.extraDirectories.paths` parameter in your `build.gradle.kts`:
```kotlin
tinyJib {
  // Copies files from 'src/main/custom-extra-dir' and '/home/user/jib-extras' instead of 'src/main/jib'
  extraDirectories.paths = listOf("src/main/custom-extra-dir", "/home/user/jib-extras")
}
```

Alternatively, the `jib.extraDirectories` parameter can be used as a closure to set custom extra directories, as well as the extra files' permissions on the container:

```kotlin
tinyJib {
  extraDirectories {
    paths = "src/main/custom-extra-dir"  // Copies files from 'src/main/custom-extra-dir'
    permissions = mapOf(
        "/path/on/container/to/fileA" to "755",  // Read/write/execute for owner, read/execute for group/other
        "/path/to/another/file" to "644",  // Read/write for owner, read-only for group/other
        "/glob/pattern/**/*.sh" to "755",
    )
  }
}
```

Using `paths` as a closure, you may also specify the target of the copy and include or exclude files:

```kotlin
  extraDirectories {
    paths {
      path {
        // copies the contents of 'src/main/extra-dir' into '/' on the container
        from = file("src/main/extra-dir")
      }
      path {
        // copies the contents of 'src/main/another/dir' into '/extras' on the container
        from = file("src/main/another/dir")
        into = "/extras"
      }
      path {
        // copies a single-file.xml
        from = "src/main/resources/xml-files"
        into = "/dest-in-container"
        includes = listOf("single-file.xml")
      }
      path {
        // copies only .txt files except for 'hidden.txt' at the source root
        from = "build/some-output"
        into = "/txt-files"
        includes = listOf("*.txt", "**/*.txt")
        excludes = listOf("hidden.txt")
      }
    }
  }
```

You can also configure `paths` and `permissions` through [lazy configuration in Gradle](https://docs.gradle.org/current/userguide/lazy_configuration.html), using providers in `build.gradle`:

```kotlin
extraDirectories {
   paths = project.provider { "src/main/custom-extra-dir" }
   permissions = project.provider { mapOf("/path/on/container/to/fileA" to "755") }
}
```

```kotlin
extraDirectories {
   paths {
     path { 
       from = project.provider { "src/main/custom-extra-dir" }
       into = project.provider { "/dest-in-container" }
       includes = project.provider { listOf("*.txt", "**/*.txt") }
       excludes = project.provider { listOf("hidden.txt") }
    }
  }
}
```

### Authentication Methods

Pushing/pulling from private registries require authorization credentials.

#### Using Docker configuration files

* Jib looks from credentials from `$XDG_RUNTIME_DIR/containers/auth.json`, `$XDG_CONFIG_HOME/containers/auth.json`, `$HOME/.config/containers/auth.json`, `$DOCKER_CONFIG/config.json`, and `$HOME/.docker/config.json`.

See [`man containers-auth.json`](https://www.mankier.com/5/containers-auth.json) for more information about the files.

#### Using Docker Credential Helpers

Docker credential helpers are CLI tools that handle authentication with various registries.

Some common credential helpers include:

* Google Container Registry: [`docker-credential-gcr`](https://cloud.google.com/container-registry/docs/advanced-authentication#docker_credential_helper)
* AWS Elastic Container Registry: [`docker-credential-ecr-login`](https://github.com/awslabs/amazon-ecr-credential-helper)
* Docker Hub Registry: [`docker-credential-*`](https://github.com/docker/docker-credential-helpers)
* Azure Container Registry: [`docker-credential-acr-*`](https://github.com/Azure/acr-docker-credential-helper)

Configure credential helpers to use by specifying them as a `credHelper` for their respective image in the `tinyJib` extension.

*Example configuration:*
```kotlin
tinyJib {
  from {
    image = "aws_account_id.dkr.ecr.region.amazonaws.com/my-base-image"
    credHelper = "ecr-login"
  }
  to {
    image = "gcr.io/my-gcp-project/my-app"
    credHelper = "gcr"
  }
}
```

#### Using Specific Credentials

You can specify credentials directly in the extension for the `from` and/or `to` images.

```kotlin
tinyJib {
  from {
    image = "aws_account_id.dkr.ecr.region.amazonaws.com/my-base-image"
    auth {
      username = USERNAME // Defined in 'gradle.properties'.
      password = PASSWORD
    }
  }
  to {
    image = "gcr.io/my-gcp-project/my-app"
    auth {
      username = "oauth2accesstoken"
      password = providers.exec { commandLine("gcloud", "auth", "print-access-token") }.standardOutput.asText
    }
  }
}
```

These credentials can be stored in `gradle.properties`, retrieved from a command (like `gcloud auth print-access-token`), or read in from a file.

For example, you can use a key file for authentication (for GCR, see [Using a JSON key file](https://cloud.google.com/container-registry/docs/advanced-authentication#using_a_json_key_file)):

```kotlin
tinyJib {
  to {
    image = "gcr.io/my-gcp-project/my-app"
    auth {
      username = "_json_key"
      password = file('keyfile.json').readText()
    }
  }
}
```


### Custom Container Entrypoint

If you don't set `tinyJib.container.entrypoint`, the default container entrypoint to launch your app will be basically `java -cp <runtime classpath> <app main class>`. (The final `java` command can be further configured by setting `tinyJib.container.{jvmFlags|args|extraClasspath|mainClass|expandClasspathDependencies}`.)

Sometimes, you'll want to set a custom entrypoint to use a shell to wrap the `java` command. For example, to let `sh` or `bash` [expand environment variables](https://stackoverflow.com/a/59361658/1701388), or to have more sophisticated logic to construct a launch command. (Note, however, that running a command with a shell forks a new child process unless you run it with `exec` like `sh -c "exec java ..."`. Whether to run the JVM process as PID 1 or a child process of a PID-1 shell is a [decision you should make carefully](https://github.com/GoogleContainerTools/distroless/issues/550#issuecomment-791610603).) In this scenario, you will want to have a way inside a shell script to reliably know the default runtime classpath and the main class that Jib would use by default. To help this, Jib >= 3.1 creates two JVM argument files under `/app` (the default app root) inside the built image.

- `/app/jib-classpath-file`: runtime classpath that Jib would use for default app launch
- `/app/jib-main-class-file`: main class

Therefore, *for example*, the following command will be able to launch your app:

`java -cp @/app/jib-classpath-file @/app/jib-main-class-file`

### Reproducible Build Timestamps

To ensure that a Jib build is reproducible, Jib sets the image creation time to the Unix epoch (00:00:00, January 1st, 1970 in UTC) and all file modification times to one second past the epoch by default. See the [Jib FAQ](https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#why-is-my-image-created-48-years-ago) for more details on reproducible builds.

Another, more complex way to achieve reproducible builds with stable creation times is to leverage commit timestamps from the project's SCM. For example, the [gradle-git-properties](https://plugins.gradle.org/plugin/com.gorylenko.gradle-git-properties) plugin can be used to inject Git commit information into the current build. These can then be used to configure `tinyJib.container.creationTime`. Since the actual Git information is not yet available at the time the build is configured, it needs to be set through [lazy configuration in Gradle](https://docs.gradle.org/current/userguide/lazy_configuration.html), using a provider in `build.gradle.kts`:

```kotlin
tinyJib {
   container {
     creationTime = project.provider { project.ext.git["git.commit.time"] }
   }
}
```

This would build an image with the creation time set to the time of the latest commit from `project.ext.git['git.commit.time']`.
